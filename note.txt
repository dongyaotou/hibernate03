hibernate对象的三种状态
01.瞬时状态（临时状态，自由状态）
    我们通过new关键字创建出一个类的实例对象，这个对象和hibernate没有一点关系
02.持久状态
    对象被session管理。就会产生一个OID（主键标识符），这个对象就和hibernate建立关系了
03.游离状态（托管状态）
    曾经被session管理过！和瞬时状态的区别在于，是否存在OID



概念：
脏检查：在一个对象被session管理的时候，会创建这个对象的快照
        我们之后在进行commit的时候，会拿当前的对象和之前对戏那个的快照进行对比
        如果当前对象的属性发生改变，那么现在的对象就是脏对象
        脏对象会被同步到数据库中


接着我们再来谈commit和flush的区别
flush()：是缓存清理，把缓存中的数据同步到数据库！
commit():比较牛逼，在执行的时候，会默认执行flush（），
         flush()在执行的时候会进行缓存清理，在缓存清理的时候，会进行脏检查！


merge的作用是：新new一个对象，如果该对象设置了ID，则这个对象就当作游离态处理：

                                      当ID在数据库中不能找到时，用update的话肯定会报异常，然而用merge的话，就会insert。

                                      当ID在数据库中能找到的时候，update与merge的执行效果都是更新数据，发出update语句；

                              如果没有设置ID的话，则这个对象就当作瞬态处理：

                               用update的话，由于没有ID，所以会报异常，merge此时则会保存数据，根据ID生产策略生成一条数

hibernate 的一级缓存是session级别的

重点：

    * 瞬时态和游离态的区别就是是否拥有OID！
     * OID怎么来的？只要曾经被session管理过的对象都有OID！
     *
     *  save():   把瞬时态转换成持久态
     *  update(): 把游离态转换成持久态
     *  saveOrUpdate():
     *         会根据对象是否有OID来判断执行save还是update
     *           如果有oid  执行update   就相当于有序号就能执行更新操作
     *           如果没有oid  执行save    就相当于没有序号就只有先保存到session会话中
     *  merge()： 产生的sql语句和saveOrUpdate有点类似，
     *            但是！！！！！
     *            01.merge不会改变对象的状态
     *            02.当我们的对象处于瞬时状态时，会将对象复制一份到session的缓存中，
     *              然后执行save方法，执行insert
     */


hibernate的三种状态中  游离状态也有时候被称为托管状态
                      瞬时状态有时候也被成为临时状态



